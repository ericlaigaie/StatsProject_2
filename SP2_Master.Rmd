---
title: "SP2_Master"
author: "Eric Laigaie"
date: "3/28/2022"
output: html_document
---

Loading in packages
```{r setup, include=FALSE}
rm(list = ls())
knitr::opts_chunk$set(echo = TRUE)
library(readr)
library(tidyverse)
library(ggplot2)
library(GGally)
library(ggpubr)
library(MASS)
library(car)
library(caret)
library(ROCR)
library(glmnet)
```

### Data is stored in a .data and .test file. Let's read them as .csvs & define the column names.
```{r}
df_train <- read.csv("https://raw.githubusercontent.com/ericlaigaie/StatsProject_2/main/train.csv")
df_test <- read.csv("https://raw.githubusercontent.com/ericlaigaie/StatsProject_2/main/test.csv")
```

### Check Nulls
```{r}
#check for number of null values in data
sapply(df_train, function(x) sum(is.na(x)))
sapply(df_test, function(x) sum(is.na(x)))

```

###summary tables
```{r}
#create summary
summary(df_train)
str(df_train)
summary(df_test)
str(df_test) # Update this from train to test.

#count number of levels
levelcount <- as.data.frame(t(df_train%>% summarise_all(n_distinct)))
colnames(levelcount) <- c('Level Count')
print(levelcount)

#added code to count the levels for test.
levelcount_tst <- as.data.frame(t(df_test%>% summarise_all(n_distinct)))
colnames(levelcount_tst) <- c('Level Count')
print(levelcount_tst)

```

### Check ? Counts
```{r}
# No ?'s in education, marital_status, relationship, race, sex, pay_response

print(paste('Train - ? Working Class:', nrow(df_train %>% filter(workclass == '?')), sep=' '))
print(paste('Train - ? Occupation:', nrow(df_train %>% filter(occupation == '?')), sep=' '))
print(paste('Train - ? Native Country:', nrow(df_train %>% filter(native_country == '?')), sep=' '))

print(paste('Test  - ? Working Class:', nrow(df_test %>% filter(workclass == '?')), sep=' '))
print(paste('Test  - ? Occupation:', nrow(df_test %>% filter(occupation == '?')), sep=' '))
print(paste('Test  - ? Native Country:', nrow(df_test %>% filter(native_country == '?')), sep=' '))
```
### Removing ? from Train and Test
```{r}
# Let's make a version 2 of train and test that has no ?'s
df_train2 <- df_train %>% filter(workclass != '?')
df_train2 <- df_train2 %>% filter(occupation != '?')
df_train2 <- df_train2 %>% filter(native_country != '?')

df_test2 <- df_test %>% filter(workclass != '?')
df_test2 <- df_test2 %>% filter(occupation != '?')
df_test2 <- df_test2 %>% filter(native_country != '?')

#Created 2 new dataframes: df_train2 and df_test2
```

### Change all strings to factors
```{r}
df_train2 <- as.data.frame(unclass(df_train2), stringsAsFactors = TRUE)
df_test2 <- as.data.frame(unclass(df_test2), stringsAsFactors = TRUE)
```

```{r}

#Rayon getting familiar with the data. Will remove from final project.
#str(df_train2)

# ? and Never-worked was removed in df_train2 and df_test2

# length(unique(df_train$workclass))
# length(unique(df_train2$workclass))

# unique(df_train$workclass)
# unique(df_train2$workclass)

#Another way to analyze the data.
# install.packages("psych")
# library(psych)
# view(describe(df_train2))

# Count of <=50K and >50K
# sum(with(df_train2,pay_response == "<=50K")) # 22654
# sum(with(df_train2,pay_response == ">50K")) #7508
# 
# sum(with(df_test2,pay_response == "<=50K.")) #11360
# sum(with(df_test2,pay_response == ">50K.")) #3700
# 
# str(df_test2)

```

### Check large factors - education
```{r}
# Let's try and see if we can collapse some levels of the education factor

# First, look at train ----------------------------------------------------------------------------------------------------


# Establish factor order
edu_levels <- c('Preschool','1st-4th','5th-6th','7th-8th','9th','10th','11th','12th','HS-grad','Some-college','Assoc-voc','Assoc-acdm','Bachelors','Masters','Prof-school','Doctorate')
df_train2 <- df_train2 %>%
  mutate(education = fct_relevel(education, edu_levels))

# Plot pay_response proportion by level
ggplot(df_train2, aes(y=education, fill=pay_response)) + geom_bar(position='fill') + labs(x='pay_response proportion', title='Pay_response Proportions by Education - Train')

# New levels of factors (any unlisted here are staying single)
grades <- c('1st-4th','5th-6th','7th-8th','9th','10th','11th','12th')
grads <- c('HS-grad','Some-college')
assocs <- c('Assoc-voc','Assoc-acdm')
docs <- c('Prof-school','Doctorate')

# Mutate education factor into new levels
df_train2 <- df_train2 %>% mutate(
  education = case_when(
      education == 'Preschool' ~ 'Preschool',
      education %in% grades ~ 'Grade School',
      education %in% grads ~ 'HS Grads',
      education %in% assocs ~ 'Assocs',
      education == 'Bachelors' ~ 'Bachelors',
      education == 'Masters' ~ 'Masters',
      education %in% docs ~ 'Docs/Profs'
    )
)

# Establish new factor order
edu_levels <- c('Preschool', 'Grade School', 'HS Grads', 'Assocs', 'Bachelors', 'Masters', 'Docs/Profs')
df_train2 <- df_train2 %>% mutate(education = factor(education), education = fct_relevel(education, edu_levels))
  
# Plot final levels
ggplot(df_train2, aes(y=education, fill=pay_response)) + geom_bar(position='fill') + labs(x='pay_response proportion', title='Pay_response Proportions by Education - Train')

# Repeat process with test ----------------------------------------------------------------------------------------------
edu_levels <- c('Preschool','1st-4th','5th-6th','7th-8th','9th','10th','11th','12th','HS-grad','Some-college','Assoc-voc','Assoc-acdm','Bachelors','Masters','Prof-school','Doctorate')
df_test2 <- df_test2 %>%
  mutate(education = fct_relevel(education, edu_levels))

# Plot pay_response proportion by level
ggplot(df_test2, aes(y=education, fill=pay_response)) + geom_bar(position='fill') + labs(x='pay_response proportion', title='Pay_response Proportions by Education - Test')

# While the distributions here are slightly different, let's keep the same groups
grades <- c('1st-4th','5th-6th','7th-8th','9th','10th','11th','12th')
grads <- c('HS-grad','Some-college')
assocs <- c('Assoc-voc','Assoc-acdm')
docs <- c('Prof-school','Doctorate')

# Mutate education factor into new levels
df_test2 <- df_test2 %>% mutate(
  education = case_when(
      education == 'Preschool' ~ 'Preschool',
      education %in% grades ~ 'Grade School',
      education %in% grads ~ 'HS Grads',
      education %in% assocs ~ 'Assocs',
      education == 'Bachelors' ~ 'Bachelors',
      education == 'Masters' ~ 'Masters',
      education %in% docs ~ 'Docs/Profs'
    )
)

# Establish new factor order
edu_levels <- c('Preschool', 'Grade School', 'HS Grads', 'Assocs', 'Bachelors', 'Masters', 'Docs/Profs')
df_test2 <- df_test2 %>% mutate(education = factor(education), education = fct_relevel(education, edu_levels))
  
# Plot final levels
ggplot(df_test2, aes(y=education, fill=pay_response)) + geom_bar(position='fill') + labs(x='pay_response proportion', title='Pay_response Proportions by Education - Test')


#Response variable (>50K) increases as the level of school increases!
```

### Check large factors - workclass
```{r workclass, fig.width=10, fig.height=6}
ggarrange(
ggplot(df_train2, aes(y=workclass, fill=pay_response)) + geom_bar(position='fill') + labs(x='pay_response proportion', title='Pay_response Proportions by Workclass - Train') + theme(legend.position='none'),
ggplot(df_test2, aes(y=workclass, fill=pay_response)) + geom_bar(position='fill') + labs(x='pay_response proportion', title='Pay_response Proportions by Workclass - Test') + theme(legend.position='none'),
nrow=1)
# There aren't too many levels here, and I can't find any pair I would really like to collapse together.
#Rayon - I agree with this. no clear way of collapsing it.All Workclass included our variable of interest. Exception is Without Pay in Training

```

### Check large factors - occupation
```{r occupation, fig.width=10, fig.height=6}
ggarrange(
ggplot(df_train2, aes(y=occupation, fill=pay_response)) + geom_bar(position='fill') + labs(x='pay_response proportion', title='Pay_response Proportions by occupation - Train') + theme(legend.position='none'),
ggplot(df_test2, aes(y=occupation, fill=pay_response)) + geom_bar(position='fill') + labs(x='pay_response proportion', title='Pay_response Proportions by occupation - Test') + theme(legend.position='none'),
nrow=1)
# While there are a lot of levels here, I don't see any groups that would make sense to collapse together.
```

### Check large factors - marital_status
```{r marital_status, fig.width=10, fig.height=6}
ggarrange(
ggplot(df_train2, aes(y=marital_status, fill=pay_response)) + geom_bar(position='fill') + labs(x='pay_response proportion', title='Pay_response Proportions by marital_status - Train') + theme(legend.position='none'),
ggplot(df_test2, aes(y=marital_status, fill=pay_response)) + geom_bar(position='fill') + labs(x='pay_response proportion', title='Pay_response Proportions by marital_status - Test') + theme(legend.position='none'),
nrow=1)
# There's not a ton of levels and I don't see any groups that would make sense to collapse together.
# Rayon I agree

```

### Check large factors - native_country
```{r}
# First, let's look at train ---------------------------------------------------------------------------------------------

ggplot(df_train2, aes(y=native_country, fill=pay_response)) + geom_bar(position='fill') + labs(x='pay_response proportion', title='Pay_response Proportions by native_country - Train')

# There are way too many levels here to keep. The most logical way to collapse these would be by continent
# Grouping by asia, europe, north america, and latin america, we are left with Outlying-US territories and 'South' -- this could be South Africa or South Korea...it is also weird that there are no African countries.

asia <- c('Cambodia','China','Hong','India','Iran','Japan','Laos','Philippines','Taiwan','Thailand','Vietnam')
europe <- c('England','France','Germany','Greece','Holand-Netherlands','Hungary','Ireland','Italy','Poland','Portugal','Scotland','Yugoslavia')
namerica <- c('Canada','United-States')
lamerica <- c('Cuba','Dominican-Republic','El-Salvador','Guatemala','Haiti','Honduras','Jamaica','Mexico','Nicaragua','Puerto-Rico','Trinadad&Tobago','Columbia','Ecuador','Peru')
islands <- c('Outlying-US(Guam-USVI-etc)')

df_train2 <- df_train2 %>% mutate(
  native_country = case_when(
      native_country %in% asia ~ 'Asia',
      native_country %in% europe ~ 'Europe',
      native_country %in% namerica ~ 'North America',
      native_country %in% lamerica ~ 'Latin America',
      native_country %in% islands ~ 'US Territories',
      TRUE ~ 'South'
    )
)

ggplot(df_train2, aes(y=native_country, fill=pay_response)) + geom_bar(position='fill') + labs(x='pay_response proportion', title='Pay_response Proportions by native_country - Train')

# Next, let's look at test -----------------------------------------------------------------------------------------------

ggplot(df_test2, aes(y=native_country, fill=pay_response)) + geom_bar(position='fill') + labs(x='pay_response proportion', title='Pay_response Proportions by native_country - test')

# There are way too many levels here to keep. The most logical way to collapse these would be by continent
# Grouping by asia, europe, north america, and latin america, we are left with Outlying-US territories and 'South' -- this could be South Africa or South Korea...it is also weird that there are no African countries.

asia <- c('Cambodia','China','Hong','India','Iran','Japan','Laos','Philippines','Taiwan','Thailand','Vietnam')
europe <- c('England','France','Germany','Greece','Holand-Netherlands','Hungary','Ireland','Italy','Poland','Portugal','Scotland','Yugoslavia')
namerica <- c('Canada','United-States')
lamerica <- c('Cuba','Dominican-Republic','El-Salvador','Guatemala','Haiti','Honduras','Jamaica','Mexico','Nicaragua','Puerto-Rico','Trinadad&Tobago','Columbia','Ecuador','Peru')
islands <- c('Outlying-US(Guam-USVI-etc)')

df_test2 <- df_test2 %>% mutate(
  native_country = case_when(
      native_country %in% asia ~ 'Asia',
      native_country %in% europe ~ 'Europe',
      native_country %in% namerica ~ 'North America',
      native_country %in% lamerica ~ 'Latin America',
      native_country %in% islands ~ 'US Territories',
      TRUE ~ 'South'
    )
)

ggplot(df_test2, aes(y=native_country, fill=pay_response)) + geom_bar(position='fill') + labs(x='pay_response proportion', title='Pay_response Proportions by native_country - test')
```

### Capital Gain & Capital Loss
```{r}
# We found that no person has nonzero gain and loss (figured as much), so how can we calculate cap_net?
df_train2 %>% filter(capital_gain != 0 & capital_loss != 0)
df_test2 %>% filter(capital_gain != 0 & capital_loss != 0)

# Since we know that cap_gain and cap_loss cannot exist together, simply calculating cap_gain - cap_loss would give us what we want...two possible cases:
#   Capital_gain exists: Capital_net = X - 0
#   Capital_loss exists: Capital_net = 0 - X

df_train2$capital_net = df_train2$capital_gain - df_train2$capital_loss
df_test2$capital_net = df_test2$capital_gain - df_test2$capital_loss

df_train2 <- dplyr::select(df_train2,-c(capital_gain, capital_loss))
df_test2 <- dplyr::select(df_test2,-c(capital_gain, capital_loss))

```

### Education & Education_Num
```{r}
# Let's check for multicollinearity

ggplot(df_train2, aes(y=education, x=education_num)) + geom_boxplot(fill='indianred2') + labs(title='Education_num distribution by Education - Train')

ggplot(df_test2, aes(y=education, x=education_num)) + geom_boxplot(fill='indianred2') + labs(title='Education_num distribution by Education - Test')

# Here, you can see that these two variables are directly related, as expected...so we can only include one. Since education is best viewed through factors (there isn't a numerical relationship between education levels), we'll keep education.

df_train2 <- dplyr::select(df_train2,-c(education_num))
df_test2 <- dplyr::select(df_test2,-c(education_num))
```

### Plot Matrix
```{r}
ggpairs(df_train2, columns = c(2,4,11,14), ggplot2::aes(colour=pay_response))

ggpairs(df_test2, columns = c(2,4,11,14), ggplot2::aes(colour=pay_response))
```

### Fix Test Typo
```{r}
# Just realized the pay_response variable is stored as '<=50K.' and '>50K.'. Let's get rid of those periods
df_test2 <- df_test2 %>% mutate(pay_response = ifelse(pay_response == '<=50K.', '<=50K', '>50K'))
```

### Response Variable Balance
```{r}
print(paste('Percentage of positive responses in Train: ',
            round((nrow(df_train2 %>% filter(pay_response == '>50K')) / nrow(df_train2)) * 100,2),
            '%', sep=''))
print(paste('Percentage of positive responses in Test: ',
            round((nrow(df_test2 %>% filter(pay_response == '>50K')) / nrow(df_test2)) * 100,2),
            '%', sep=''))

```

### What's Next?
1. We should look through the factor variables for any evidence of collinearity.

```{r workclass vs. education}

#Mosaic Plot
#Don't observe any multicullinearity

t(aggregate(workclass~education,data=df_train2,summary))
plot(df_train2$workclass~df_train2$education,col=c("orange","blue"))
```

```{r maritalstatus vs education}
#Mosaic Plot
#Don't observe any multicullinearity

t(aggregate(marital_status~education,data=df_train2,summary))
plot(df_train2$marital_status~df_train2$education,col=c("orange","blue"))

```

```{r Race vs education}

t(aggregate(race~education,data=df_train2,summary))
plot(df_train2$race~df_train2$education,col=c("orange","blue"))

df_train2 %>%
  count(race, education) %>%
  ggplot(mapping = aes(x = race, y = education)) +
  geom_tile(mapping = aes(fill = n))

```





2. We should consider if variables make sense to include in the model (fnlwgt).

### Objective 1 - Stepwise & LASSO Models
```{r}
# Create the model with selection
full.log<-glm(pay_response~.,family="binomial",data=df_train2)
step.log<-full.log %>% stepAIC(trace=FALSE)

# Summary of model
summary(step.log)

# Odds ratios of model
exp(cbind("Odds ratio" = coef(step.log), confint.default(step.log, level = 0.95)))

# Make predictions on model
fit.pred.step<-predict(step.log,newdata=df_test2,type="response")

# Set cutoff and make classifications from predictions
cutoff<- 0.5
class.step<-factor(ifelse(fit.pred.step>cutoff,">50K","<=50K"),levels=c("<=50K",">50K"))

# Print confusion matrix
conf.step<-table(class.step,df_test2$pay_response)
cm.step <- confusionMatrix(conf.step)
cm.step

# Test different cutoffs - create vectors to store cutoffs and accuracies
step.cutoffs <- seq(.1,.9,.01)
step.accuracies <- c()

# Loop through cutoffs and find confusion matrix and accuracy of new classifications
for (i in step.cutoffs) {
  curr.class.step <- factor(ifelse(fit.pred.step>i,">50K","<=50K"),levels=c("<=50K",">50K"))
  curr.conf.step <- table(curr.class.step,df_test2$pay_response)
  curr.cm.step <- confusionMatrix(curr.conf.step)
  
  step.accuracies <- append(step.accuracies, 100*curr.cm.step$overall[1])
}

# Create dataframe from vectors and establish max value for each column
step.cutoff_acc_loop <- data.frame('cutoffs' = step.cutoffs, 'accuracies' = step.accuracies)
step.maxacc <- max(step.cutoff_acc_loop$accuracies)
step.maxcut <- step.cutoff_acc_loop %>% filter(accuracies == step.maxacc) %>% pull(cutoffs)

# Create accuracy geom_line chart and mark maximum accuracy
ggplot(step.cutoff_acc_loop, aes(x=cutoffs, y=accuracies, label=accuracies)) + 
  geom_line(size=2, color='indianred2') +
  labs(x='Classiciation Cutoff', y='Accuracy', title='Accuracy by Cutoff Value - Stepwise') +
  geom_point(aes(y=step.maxacc, x=step.maxcut), size=5, color='black') +
  geom_text(
    aes(label=
          ifelse(accuracies == step.maxacc,
                 paste(round(accuracies,2),'%, cutoff = ',step.maxcut,sep='')
                 ,'')
        ),hjust=-.2, vjust=0
    )
```

```{r}
# Prepare matrices
dat.train.x <- model.matrix(pay_response~.-1,df_train2)
dat.train.y<-df_train2[,13]

# Do cross-validation and plot
cvfit <- cv.glmnet(dat.train.x, dat.train.y, family = "binomial", type.measure = "class", nlambda = 1000)
plot(cvfit)
coef(cvfit, s = "lambda.min")
print("CV Error Rate:")
cvfit$cvm[which(cvfit$lambda==cvfit$lambda.min)]

#Optimal penalty
print("Penalty Value:")
cvfit$lambda.min

#For final model predictions go ahead and refit lasso using entire
#data set
finalmodel<-glmnet(dat.train.x, dat.train.y, family = "binomial",lambda=cvfit$lambda.min)

#Test set predictions & confusion matrix
dat.test.x<-model.matrix(pay_response~.-1,df_test2)
fit.pred.lasso <- predict(finalmodel, newx = dat.test.x, type = "response")

# Set cutoff and make classifications off of predictions
cutoff<-0.5
class.lasso<-factor(ifelse(fit.pred.lasso>cutoff,">50K","<=50K"),levels=c("<=50K",">50K"))

#Confusion Matrix for Lasso
conf.lasso<-table(class.lasso,df_test2$pay_response)
confusionMatrix(conf.lasso)

# Test different cutoffs - create vectors to store cutoffs and accuracies
lasso.cutoffs <- seq(.1,.9,.01)
lasso.accuracies <- c()

# Loop through cutoffs and find confusion matrix and accuracy of new classifications
for (i in lasso.cutoffs) {
  curr.class.lasso <- factor(ifelse(fit.pred.lasso>i,">50K","<=50K"),levels=c("<=50K",">50K"))
  curr.conf.lasso <- table(curr.class.lasso,df_test2$pay_response)
  curr.cm.lasso <- confusionMatrix(curr.conf.lasso)
  
  lasso.accuracies <- append(lasso.accuracies, 100*curr.cm.lasso$overall[1])
}

# Create dataframe from vectors and establish max value for each column
lasso.cutoff_acc_loop <- data.frame('cutoffs' = lasso.cutoffs, 'accuracies' = lasso.accuracies)
lasso.maxacc <- max(lasso.cutoff_acc_loop$accuracies)
lasso.maxcut <- lasso.cutoff_acc_loop %>% filter(accuracies == lasso.maxacc) %>% pull(cutoffs)

# Create accuracy geom_line chart and mark maximum accuracy
ggplot(lasso.cutoff_acc_loop, aes(x=cutoffs, y=accuracies, label=accuracies)) + 
  geom_line(size=2, color='indianred2') +
  labs(x='Classiciation Cutoff', y='Accuracy', title='Accuracy by Cutoff Value - lassowise') +
  geom_point(aes(y=lasso.maxacc, x=lasso.maxcut), size=5, color='black') +
  geom_text(
    aes(label=
          ifelse(accuracies == lasso.maxacc,
                 paste(round(accuracies,2),'%, cutoff = ',lasso.maxcut,sep='')
                 ,'')
        ),hjust=-.2, vjust=0
    )
```

```{r}
# Prepare LASSO ROC Curve
results.lasso<-prediction(fit.pred.lasso, df_test2$pay_response,label.ordering=c("<=50K",">50K"))
roc.lasso = performance(results.lasso, measure = "tpr", x.measure = "fpr")

# Prepare Step ROC Curve
results.step<-prediction(fit.pred.step, df_test2$pay_response,label.ordering=c("<=50K",">50K"))
roc.step = performance(results.step, measure = "tpr", x.measure = "fpr")

plot(roc.lasso)
plot(roc.step,col="orange", add = TRUE)
legend("bottomright",legend=c("Lasso","Stepwise"),col=c("blue", "orange"),lty=1,lwd=1)
abline(a=0, b= 1)
```

#LDA CODE 

```{r LDA}

lda.fit = lda(pay_response~., data = df_train2[,-1])

lda.fit

##Predict Training Results
predmodel.train.lda <-  predict(lda.fit, data=df_train2)
predmodel.train.lda

# Create table to get prediction accuracy
table(Predicted <- predmodel.train.lda$class, pay_response = df_train2$pay_response)
conf_matrix_train <-  table(Predicted <- predmodel.train.lda$class, pay_response = df_train2$pay_response)

sensitivity(conf_matrix_train)
specificity(conf_matrix_train)


# print out histogram to show split
ldahist(predmodel.train.lda$x[,1], g= predmodel.train.lda$class)

#Test
predmodel.test.lda = predict(lda.fit, newdata=df_test2)
table(Predicted=predmodel.test.lda$class, pay_response=df_test2$pay_response)

conf_matrix_test <- table(Predicted=predmodel.test.lda$class, pay_response=df_test2$pay_response)

cm_test <-  confusionMatrix(conf_matrix_test)
cm_test
```

### LDA Assumptions

Assumption for equal variances between groups for each variable
```{r LDAassumptions1, fig.height=6, fig.width=10}
lda_eq_var <- function(myVar) {
ggplot(df_train2, aes_string(x='pay_response', y={{myVar}}, fill='pay_response')) + 
  geom_boxplot() + 
  theme(legend.position='none') +
  labs(title=paste({{myVar}}, "by pay_response", sep=' '))
}

ggarrange(lda_eq_var("age"),lda_eq_var("fnlwgt"),lda_eq_var("hours_per_week"),lda_eq_var("capital_net"),nrow=2,ncol=2)

lda_eq_var_cov <- function(myVarX, myVarY) {
ggplot(df_train2, aes_string(x = {{myVarX}}, y = {{myVarY}}, col = 'pay_response')) + 
    geom_point() + 
    stat_ellipse() +
    labs(title=paste({{myVarX}},'vs.',{{myVarY}},'by outcome', sep=' ')) +
    theme(legend.position='none')
}

ggarrange(lda_eq_var_cov("age","fnlwgt"), 
          lda_eq_var_cov("age","hours_per_week"),
          lda_eq_var_cov("age","capital_net"),
          lda_eq_var_cov("fnlwgt","hours_per_week"),
          lda_eq_var_cov("fnlwgt","capital_net"),
          lda_eq_var_cov("hours_per_week","capital_net"),
          nrow=2, ncol=3
)
```

Normality assumption
```{r}
pay.yes <- subset(df_train2, pay_response == ">50K") 
pay.no <- subset(df_train2, pay_response == "<=50K")

variable_1 <- c("age", "fnlwgt", "hours_per_week", "capital_net") 
par(mfrow = c(2, 2)) 
for(i in variable_1) { 
    qqnorm(pay.yes[[i]]); qqline(pay.yes[[i]], col = 2) 
}

par(mfrow = c(2, 2)) 
for(i in variable_1) { 
    qqnorm(pay.no[[i]]); qqline(pay.no[[i]], col = 2) 
}
```


